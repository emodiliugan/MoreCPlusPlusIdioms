# Final Class(最终类)

##目的

- 部分模拟其他语言中的最终类特性。
- 部分防止类被进一步子类化或继承。

##别名
##动机

类设计者可能希望强制执行特定类不能被用户进一步扩展或子类化的规定。其他面向对象的语言例如Java和C#为类设计者提供了这个功能。在Java中，关键字称为final，而在C#中，它称为sealed。最终类惯用语是在C++中部分模拟这种效果的一种方式。(**注意：在C++11以后提供了final修饰符，可用于防止类被派生**)

##解决方案及示例

**C++11之前：**

最终类惯用法利用虚拟继承和友元类来创建最终类的效果。这种惯用法依赖于以下C++规则：虚拟继承类的构造函数（和析构函数）由最终派生类直接调用。如果阻止对这种虚拟继承类的构造函数或析构函数的访问，该类就无法进一步派生。

```
class MakeFinal
{
	MakeFinal() {} // private by default.
	friend class sealed;
};
class sealed : virtual MakeFinal
{ };
class test : public sealed
{ };
int main (void)
{
	test t; // Compilation error here.
}
这段代码的意思是，使用一个虚拟继承的技巧来实现一个类的final属性，即阻止这个类被继承。具体的解释如下：
1.定义了一个类 MakeFinal ，它的构造函数是私有的，这意味着它不能被外部创建或者继承。
2.定义了一个类 sealed ，它是 MakeFinal 的友元类，也是 MakeFinal 的虚拟继承类。友元类可以访问私有成员，虚拟继承类可以保证只有一个基类实例。
3.定义了一个类 test ，它试图继承 sealed 类。但是，由于虚拟继承的规则， test 类必须调用 MakeFinal 的构造函数来初始化基类实例，而 MakeFinal 的构造函数是私有的，因此 test 类无法继承 sealed 类，编译器会报错。
因此，这段代码实现了让 sealed 类成为一个 final 类，不能被继承的效果。
划个重点：虚拟继承的规则，当一个类虚拟继承另外一个类的时候，它必须在自己的构造函数中显示调用基类的构造函数来初始化基类的实例，这是为了保证虚拟继承的正确性和一致性，避免二义性。

上面的例子里：
问：sealed虚拟继承了MakeFinal，为什么它没有显式调用基类的构造函数？
答：这是因为 sealed 类没有定义自己的构造函数，而是使用了默认的构造函数。默认的构造函数会隐式地调用基类的构造函数，如果基类的构造函数是私有的，那么只有友元类可以调用它。因为 sealed 类是 MakeFinal 类的友元类，所以它可以隐式地调用 MakeFinal 类的私有构造函数，而不会报错。
问：test类也没有定义自己的构造函数，为什么它没办法隐式调用呢？
答：虚继承有一个限制，就是虚基类的构造函数必须由最终派生类来调用，而不是中间的派生类。也就是说，如果有一个类A从MakeFinal类虚继承，然后有一个类B从A类继承，那么B类的构造函数必须在初始化列表中调用MakeFinal类的构造函数，而不是A类的构造函数。这样可以保证虚基类的构造函数只被调用一次，而不是多次。
	所以，在这个例子中，虽然sealed类默认调用了MakeFinal类的构造函数，但是它并没有真正执行它，而是把它传递给了test类。test类作为最终派生类，必须在初始化列表中调用MakeFinal类的构造函数。但是因为test类不是MakeFinal类的友元类，所以它不能调用MakeFinal类的私有构造函数。这就导致了编译错误。
```

在上面的例子里，test类继承自sealed，而在main函数里尝试将其实例化为一个对象，实例化失败，因为它被定义为私有构造函数并是虚拟继承，test类无法访问MakeFinal类的私有构造函数，而test又不是MakeFinal的友元，因此无法创建test类的对象。

提醒一下，上述错误仅在实例化test类时发生。这种行为与Java和C#中关键字final的行为不同。实际上，这种惯用法并不防止从sealed类中继承静态方法。只要test类没有被实例化，只访问最终类的静态成员，编译器就不会报错。

##C++11

C++11标准提供了final修饰符，可以用于防止类被派生。使用final修饰符可以在类定义中将其派生类声明为final。例如，在C++11中，可以使用以下方式定义最终类：

```
class Base final { };
class test : public Base { }; // 不正确
```

##已知的应用
##相关的惯用法
##参考