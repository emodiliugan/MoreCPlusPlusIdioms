# 复制与交换 (Copy-and-swap)
##目的
创建一个异常安全的赋值运算符重载。

##别名
Create-Temporary-and-Swap

##动机
异常安全(Exception safety)是构建高度安全的C++软件的重要基石，它使用异常(exceptions)来表示异常的事件。至少有三种异常安全性级别:基本(basic)、强(strong)和no-throw。一般使用基本异常，毕竟实现简单。强异常安全在一些情况下并不适用。

**本惯用法就是为了让赋值操作值能够以强异常安全的方式实现。**

    关于异常安全性的三种类型 (《Effective C++》中Item 29):
    * 基本承诺
    如果异常抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态。但是程序的状态可能无法预料。
    举个例子，我们可以撰写 changeBackground使得一旦有异常被抛出时，PrettyMenu对象可以继续拥有原背景图像，或是令它拥有某个缺省背景图像，但客户无法预期哪一种情况。如果想知道，他们恐怕必须调用某个成员函数以得知当时的背景图像是什么。
    
    * 强烈保证
    如果异常抛出，程序状态不改变。调用这样的函数需有这样的认知:如果函数成功，就是完全成功，如果函数失败，程序会恢复到调用函数之前的状态。
    和这种提供强烈保证的函数共事，比和刚才说的那种只提供基本承诺的函数共事，容易多了，因为在调用一个提供强烈保证的函数后，程序状态只有两种可能：如预期般地到达函数成功执行后的状态，或回到函数被调用前的状态。与此成对比的是，如果调用一个只提供基本承诺的函数，而真的出现异常，程序有可能处于任何状态——只要那是个合法状态。
    
    * 不抛掷保证
    承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于内置类型身上的所有操作都提供nothrow保证。

##解决方案及示例
使用本惯用法会在丢掉当前资源之前取得新资源。其中使用RAII惯用法获取资源，如果成功获取资源，再使用non-throwing swap idiom(无异常swap惯用法)。最终，旧资源在RAII的副作用下被释放掉。

```
class String
{
    char* str;
public:
    String& operator=(const String& s)
    {
        String temp(s); // 拷贝建构 -- RAII
        temp.swap(*this); // 无异常swap

        return *this;
    } // 在temp析构时，旧资源会被释放。
    void swap(String & s) throw() // 无异常swap的实现
    {
        std::swap(this->str, s.str);
    }
};
```

还有一些上面这个实现的变种。自赋值操作虽然不是强制需要的，但它在自赋值的情况下带来性能提升(虽然很少发生)。
```
class String
{
    char * str;
public:
    String& operator=(const String& s)
    {
        if (this != &s)
        {
            String(s).swap(*this); //拷贝建构，以及无异常的swap
        }

        // 在temp析构时，旧资源会被释放。
        return *this;
    }
    void swap(String& s) throw() // 无异常swap的实现
    {
        std::swap(this->str, s.str);
    }
};
```

**补充知识**：

throw()和noexcept都是C++中的异常规范，用来指示函数是否会抛出异常。它们的区别如下：

- throw()是C++03中的语法，noexcept是C++11中引入的新语法，用来替代throw()。

- throw()可以接受一个类型列表，表示函数可以抛出的异常类型，例如throw(int,double)。但这种用法在C++11中已经被弃用，并在C++17中被删除。如果throw()不接受任何参数，表示函数不会抛出任何异常，例如throw()。这种用法在C++17中被noexcept(true)取代。

- noexcept可以接受一个常量表达式，表示函数是否可能抛出异常，例如noexcept(true)或noexcept(false)。如果noexcept不接受任何参数，表示函数不会抛出任何异常，相当于noexcept(true)。

- 当一个函数被声明为throw()或noexcept(true)时，如果函数试图抛出异常，程序的行为是不同的。在C++14及更早的版本中，throw()会调用std::unexpected函数，而noexcept(true)会调用std::terminate函数。在C++17及更高的版本中，throw()和noexcept(true)都会调用std::terminate函数。

- noexcept可以增强泛型编程的能力，因为它可以根据模板参数的表达式来决定函数是否是noexcept的。例如，template void fun () noexcept (noexcept (T ())) {}就是一个根据T()表达式是否可能抛出异常来决定fun()是否是noexcept的模板函数。

  具体的更多细节可以参考：

  [noexcept关键字](https://zhuanlan.zhihu.com/p/196164710)

  [C++03 throw()说明符 C++11 noexcept之间的区别](https://qastack.cn/programming/12833241/difference-between-c03-throw-specifier-c11-noexcept)

**拷贝省略(copy ellsion)和copy-and-swap惯用法**
严格来说，在赋值操作中显示地创建临时对象是不需要的。赋值操作的右参形式的参数可以通过以值的形式传递到函数。这个参数本身就是临时变量。

```
String & operator=(String s) // 以值传递的参数s就是临时变量
{
   s.swap(*this); // 无异常swap
   return *this;
} // s的析构函数被调用时，旧资源会被释放。
```
这不仅仅为了方便才这么做的，而是实实在在的优化。如果参数(s)绑定到左值(另一个非常量对象)，就会在创建参数(s)时会自动创建一个复本。如果绑定到右值(临时变量，常量)，这个复制会被忽略掉（拷贝省略），这样就节省了拷贝建构和析构的开销。在早期版本的赋值运算符中，参数被接受为 const 引用时，当引用绑定到右值时，复制省略不会发生。这会导致创建和销毁额外的对象。

```
备注：对上面“在早期版本的赋值运算符中，参数被接受为 const 引用时，当引用绑定到右值时，复制省略不会发生。这会导致创建和销毁额外的对象”再详细解释下，在 C++ 中，复制省略是一种编译器优化技术，它可以避免在某些情况下创建和销毁对象的开销，并提高程序的性能。在使用赋值运算符时，如果编译器能够确定不需要创建临时对象来保存右值，就可以使用复制省略来避免不必要的操作。

举个例子：

MyClass& operator=(const MyClass& other) {
    // implementation
    return *this;
}

MyClass a;
a = MyClass(); // 将一个右值对象赋值给 a
在这种情况下，右值对象 `MyClass()` 会被传递给赋值运算符，然后被绑定到一个常量引用上。由于常量引用不能被修改，编译器无法对其进行优化，并执行复制省略。因此，编译器将不得不创建一个临时对象来保存右值，然后将其复制到 `a` 中。

这个临时对象的创建和销毁会带来一些开销，特别是当类的资源管理比较复杂时，例如动态分配的内存或打开的文件句柄。因此，在这种情况下使用常量引用作为赋值运算符的参数可能会影响程序的性能，因为它无法使用复制省略来避免不必要的对象创建和销毁操作。

相反，如果我们使用一个接受右值引用的赋值运算符，例如：

MyClass& operator=(MyClass&& other) {
 	// implementation
 	return *this;
}

当一个右值对象传递给这个运算符时，它会被绑定到一个右值引用上。由于右值引用是可修改的，编译器可以对其进行优化，并执行复制省略。因此，在这种情况下，编译器不需要创建临时对象来保存右值，从而避免了不必要的对象创建和销毁操作，提高了程序的性能。
```

在C++11里，这类赋值运算符也被称为统一赋值运算符(unifying assignment operator),因为它免去写两个不同赋值运算符的麻烦:拷贝赋值运算符和move赋值运算符。只要一个类有move构造函数，C++11编译器通常会用它来优化临时变量拷贝的方式。非C++11编译器可以利用拷贝省略(Copy-elision)达到和C++11编译器相同的优化效果。
```
String createString(); // 一个返加String对象的函数。
String s;
s = createString();
// 右手边是一个右值。以值传递赋值运算符的赋值运算符比以常量引用传递的方式会更为有效
```

也不是所有的类都能从这样的赋值运算符上受益。考虑一个字串的赋值运算符，字串内部持有一个右值字串对象的复本，当内存不足时，它会释放旧的内存再分配的内存。如果应用之前讨论的优化，就必须写一个自定义的赋值运算符。因为新字串的拷贝会使得之前内存分配优化失效，这个自定义的赋值运算符就必须避免从一个临时字串对象拷贝，**而且要接受常量引用的参数**。

```
备注：

对于最后一句话，举个例子：

#include <string>
#include <iostream>

using namespace std;

string foo() {
    string s = "Hello";
    return s;
}

int main() {
    string a = "World";
    a = foo(); // 调用移动赋值运算符
    cout << a << endl;
    return 0;
}

在这段代码中，函数`foo`返回一个临时的字串对象，它的内存是动态分配的。当它被赋值给字串对象`a`时，如果使用移动语义，就会把临时对象的内存转移给`a`，而不需要拷贝数据。但是，这里有一个问题：`a`原来已经有一块内存，用来存储"World"这个字串。如果使用移动语义，就会导致`a`原来的内存被丢弃，而没有被正确地释放，造成内存泄漏。而且，这个转移也是多余的，因为`a`原来的内存已经足够大，可以容纳"Hello"这个字串。所以，在这种情况下，使用传统的赋值运算符，接受一个常量引用作为参数，并根据需要拷贝数据，就会更合理和高效。
```

##已知的应用

##相关的惯用法
* RAII (Resource Acquisition Is Initialization)
* Not-throwing swap

##参考
