# Barton-Nackman技巧 (Barton-Nackman trick)
##目的

不依赖名称空间或者函数模板重载，来支持重载操作符

##别名

发明者最初将其称为受限模板扩展（尽管这个术语

从未被广泛使用过）

##动机

为了解决这个问题，约翰·巴顿和李·纳克曼在1994年首次发表了这个惯用法，当时是为了应用到c++实现的限制。虽然现在已经不是了

由于其最初的目的，但是当前的标准依然保留了对它的支持。

在Barton和Nackman最初开发这个惯用法的时候，c++并不支持

函数模板的重载和许多实现仍然不支持名称空间（namespaces）。这在为类模板定义操作符重载时会导致问题。考虑下面的类:

```c++
template<typename T>

class List{

//……

}；
```

定义相等操作符最自然的方法是在namespace中编写一个非成员函数(但是由于当时的编译器并不支持namespace，因此函数在global范围内)。将operator==定义为非成员函数意味着这两个参数都会被同等的处理，如果一个参数是指向对象的this指针，就不会发生这种情况。

这样的相等运算符可能是这样的:

```
template<typename T>

bool operator== (List<T> const& left, List<T> Const& rgt) {

//……

}
```

然而，当时由于函数模板不能重载，而且将函数放在其自己的命名空间中并不能在所有平台上工作，这意味着只有类才可以有这样一个相等操作符。如果有第二种类型做同样的事情将会造成歧义。

##解决方案及示例

解决方法是在类中定义一个操作符重载函数作为友元函数:

```
template<typename T>

class List{

public:

friend bool operator==(const List<T>& lft,
		const List<T>& rgt){
	 //....
	}
}；
```

现在实例化模板会导致一个非模板函数被注入全局作用域，其参数类型是具体的固定类型。与其他非模板函数一样，可以通过函数重载来选择这个非模板函数。通过将友元函数作为奇异递归模板模式继承的基类的一部分来提供，可以将其实现泛化。

##已知的应用

[Boost.Operators library]( http://www.boost.org/doc/libs/1_50_0/libs/utility/operators.htm)

##相关的惯用法

奇异递归模板模式（Curiously Recurring Template  Pattern，CRTP）是一种C++设计模式，用于在编译时实现静态多态性。该模式利用了C++模板的特性和继承机制，通过在基类中将派生类作为模板参数来实现静态多态。具体而言，派生类继承自基类，并将自己作为基类的模板参数，从而在编译时生成基类的特化版本，以实现静态多态性。这种技术常用于实现类似于“模板模式”和“策略模式”的设计模式，以及增强运行时多态的性能。

##参考
