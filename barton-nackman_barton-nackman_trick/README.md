# Barton-Nackman技巧 (Barton-Nackman trick)
##目的

不依赖名称空间或者函数模板重载，来支持重载操作符

##别名

发明者最初将其称为受限模板扩展（尽管这个术语

从未被广泛使用过）

##动机

为了解决这个问题，约翰·巴顿和李·纳克曼在1994年首次发表了这个惯用法，当时是为了应用到c++实现的限制。虽然现在已经不是了

由于其最初的目的，但是当前的标准依然保留了对它的支持。

在Barton和Nackman最初开发这个惯用法的时候，c++并不支持

函数模板的重载和许多实现仍然不支持名称空间（namespaces）。这在为类模板定义操作符重载时会导致问题。考虑下面的类:

```c++
template<typename T>

class List{

//……

}；
```

定义相等操作符最自然的方法是在namespace中编写一个非成员函数(但是由于当时的编译器并不支持namespace，因此函数在global范围内)。将operator==定义为非成员函数意味着这两个参数都会被同等的处理，如果一个参数是指向对象的this指针，就不会发生这种情况。

这样的相等运算符可能是这样的:

```
template<typename T>

bool operator== (List<T> const& left, List<T> Const& rgt) {

//……

}
```

然而，当时由于函数模板不能重载，而且将函数放在其自己的命名空间中并不能在所有平台上工作，这意味着只有类才可以有这样一个相等操作符。如果有第二种类型做同样的事情将会造成歧义。

##解决方案及示例

解决方法是在类中定义一个操作符重载函数作为友元函数:

```
template<typename T>

class List{

public:

friend bool operator==(const List<T>& lft,
		const List<T>& rgt){
	 //....
	}
}；
```

现在实例化模板会导致一个非模板函数被注入到global中

参数类型为具体的固定类型的作用域。这个非模板函数可以

通过函数重载解析选择，方法与其他非模板相同

函数。

实现可以通过提供友元函数作为基的一部分来一般化

类通过好奇循环模板模式继承

##已知的应用

##相关的惯用法

##参考
